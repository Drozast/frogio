version: '3.8'

# FROGIO - Docker Compose COMPLETO Y AUTOCONTENIDO
# Incluye PostgreSQL, Backend, Web Admin y todos los servicios necesarios
# Todo aislado en su propia red, sin conflictos con otros servicios del servidor

services:
  # PostgreSQL Database - Contenedor propio de Frogio
  postgres:
    image: postgres:16-alpine
    container_name: frogio-postgres
    restart: unless-stopped
    environment:
      POSTGRES_DB: frogio
      POSTGRES_USER: frogio
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-N8H+JG/UTBQVE6G+qUJAil4n/MkLjks/o7LzMBnrU40=}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./apps/backend/prisma/migrations:/docker-entrypoint-initdb.d
    ports:
      # Cambiado a 5433 para evitar conflicto con PostgreSQL del host en 5432
      - "5433:5432"
    networks:
      - frogio_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U frogio -d frogio"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s

  # Backend API
  backend:
    build:
      context: ./apps/backend
      dockerfile: Dockerfile
    container_name: frogio-backend
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      NODE_ENV: production
      PORT: 3000
      # Database conecta al contenedor postgres, NO al host
      # Password URL-encoded: + = %2B, / = %2F, = = %3D
      DATABASE_URL: postgresql://frogio:N8H%2BJG%2FUTBQVE6G%2BqUJAil4n%2FMkLjks%2Fo7LzMBnrU40%3D@postgres:5432/frogio
      # API URLs
      API_URL: http://backend:3000
      # CORS: Permite acceso desde múltiples orígenes (web-admin, mobile apps, etc)
      CORS_ORIGIN: "*"
      # Tenant
      DEFAULT_TENANT: santa_juana
      # JWT Secrets
      JWT_SECRET: ${JWT_SECRET:-P1Y6WIRSRrtvrA6lPZgGZRBeG6u3e6ZSMtUPiOCFecU=}
      JWT_REFRESH_SECRET: ${JWT_REFRESH_SECRET:-L+nRTojTNZgr1SUqBfdKpeuZ0I/4ZzxxN8LYLxLI9vc=}
      JWT_EXPIRES_IN: 15m
      JWT_REFRESH_EXPIRES_IN: 7d
      # MinIO Configuration
      MINIO_ENDPOINT: minio
      MINIO_PORT: 9000
      MINIO_ACCESS_KEY: ${MINIO_ACCESS_KEY:-frogio_admin}
      MINIO_SECRET_KEY: ${MINIO_SECRET_KEY:-frogio_secret_key_2024}
      MINIO_BUCKET: frogio-files
      MINIO_USE_SSL: "false"
      # ntfy Configuration
      NTFY_URL: http://ntfy:80
      NTFY_TOPIC: frogio-notifications
    ports:
      - "3000:3000"
    networks:
      - frogio_network
    volumes:
      - ./apps/backend/logs:/app/logs
    healthcheck:
      test: ["CMD-SHELL", "node -e \"require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})\""]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # Web Admin (Next.js)
  web-admin:
    build:
      context: ./apps/web-admin
      dockerfile: Dockerfile
    container_name: frogio-web-admin
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
    environment:
      NODE_ENV: production
      # Server-side API URL (usa nombre del contenedor)
      API_URL: http://backend:3000
      # Client-side API URL (usa dominio de Cloudflare para acceso externo)
      NEXT_PUBLIC_API_URL: https://api.frogio.drozast.xyz
      NEXT_PUBLIC_TENANT_ID: santa_juana
    ports:
      - "3010:3000"
    networks:
      - frogio_network
    healthcheck:
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://127.0.0.1:3000/ || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s

  # MinIO - Almacenamiento de archivos S3-compatible
  minio:
    image: minio/minio:latest
    container_name: frogio-minio
    restart: unless-stopped
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ACCESS_KEY:-frogio_admin}
      MINIO_ROOT_PASSWORD: ${MINIO_SECRET_KEY:-frogio_secret_key_2024}
    volumes:
      - minio_data:/data
    ports:
      # Puertos cambiados para evitar conflicto con Portainer/MinIO del host
      - "9010:9000"
      - "9011:9001"
    networks:
      - frogio_network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3
      start_period: 30s

  # ntfy - Notificaciones Push
  ntfy:
    image: binwiederhier/ntfy:latest
    container_name: frogio-ntfy
    restart: unless-stopped
    command: serve
    environment:
      NTFY_BASE_URL: ${NTFY_BASE_URL:-https://ntfy.frogio.drozast.xyz}
    volumes:
      - ntfy_data:/var/cache/ntfy
    ports:
      # Puerto cambiado para evitar conflicto con PiHole en 8080
      - "8085:80"
    networks:
      - frogio_network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:80/v1/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  # Cloudflare Tunnel - Expone servicios con subdominios de drozast.xyz
  # Usa token del túnel en lugar de archivo de credenciales
  # Obtener token: Cloudflare Dashboard > Zero Trust > Access > Tunnels > Create
  cloudflared:
    image: cloudflare/cloudflared:latest
    container_name: frogio-cloudflared
    restart: unless-stopped
    # Método 1: Con archivo de config (requiere credentials.json)
    # command: tunnel --config /etc/cloudflared/config.yml run
    # Método 2: Con token (más simple, se configura desde Cloudflare Dashboard)
    command: tunnel run --token ${CLOUDFLARE_TUNNEL_TOKEN:-YOUR_TUNNEL_TOKEN_HERE}
    environment:
      - TUNNEL_ORIGIN_CERT=/etc/cloudflared/cert.pem
    volumes:
      - ./cloudflare:/etc/cloudflared:ro
    network_mode: host
    depends_on:
      backend:
        condition: service_healthy
      web-admin:
        condition: service_healthy
      minio:
        condition: service_healthy

volumes:
  postgres_data:
    driver: local
    name: frogio_postgres_data
  minio_data:
    driver: local
    name: frogio_minio_data
  ntfy_data:
    driver: local
    name: frogio_ntfy_data

networks:
  frogio_network:
    driver: bridge
    name: frogio_network
